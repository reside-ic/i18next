---
title: "Translating with traduire"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{traduire}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  error = FALSE)
lang_output <- function(language, text) {
  writeLines(c(paste0("```", language),  text, "```"))
}
```

The `traduire` R package provides a wrapper around the [`i18next` JavaScript library](https://i18next.com).  It presents an alternative interface to R's built-in internationalisation functions, with a focus on the ability to change the target language within a session.  Currently the package presents only a stripped down interface to the underlying library, though this may expand in future.

First, prepare a `json` file with your translations.  For example, the included file `examples/simple.json` contains:

```{r, results = "asis", echo = FALSE}
path <- system.file("examples/simple.json", package = "traduire",
                    mustWork = TRUE)
lang_output("json", readLines(path))
```

We can create a translator, setting the default language to English (en) as:

```{r}
translator <- traduire::i18n(path, "en")
translator
```

With this object we can perform translations with the `t` method by passing in a key from within our translations:

```{r}
translator$t("hello")
```

Specify the `language` argument to change language:

```{r}
translator$t("hello", language = "fr")
```

## Pluralisation

Pluralisation of results is supported using keys that include `_plural` suffix (see the [`i18next` documentation](https://www.i18next.com/translation-function/plurals)) and by passing a `count` argument in to the translation:

```{r}
translator$t("pluralex1", count = 1, language = "en")
translator$t("pluralex1", count = 2, language = "en")
```

## Interpolation

String interpolation is done using a syntax very similar to [`glue`](https://cran.r-project.org/package=glue) (see the [`i18next` documentation](https://www.i18next.com/translation-function/interpolation))

```{r}
translator$t("interpolate", list(what = "i18next", how = "easy"),
             language = "en")
translator$t("interpolate", list(what = "i18next", how = "facile"),
             language = "fr")
```

## Use within a package

We provide an optional workflow for using translations within a package, or some other piece of code where the translations will be fairly invasive to add, allowing you to write essentially:

```r
traduire::t_(...)
```

and have all the `...` arguments forwarded to the appropriate translator object. There are several details here:

* how do we determine what is the "appropriate" translator object
* how do we determine what language is active for this translation?

To do this, we allow packages (or other similar code) to "register" a translator, like

```r
traduire::translator_register(resources)
```

where `resources` is passed to `traduire::i18n`.

Below is the code in use in an example package, which can say rough translations of "hello world" in a number of languages:

```{r, results = "asis", echo = FALSE}
path_hello <- system.file("hello", package = "traduire", mustWork = TRUE)
content <- readLines(file.path(path_hello, "R", "hello.R"))
lang_output("r", content[!grepl("^#", content)])
```

Here,

* `hello` is a simple function that does no translation
* `world` is a function that translates with an explicit language argument, but finds the translations automagically
* `monde` is a function that translates and finds both the translations and the language automagically

The `.onLoad` function contains a call to `traduire::translator_register` which registers a translator database for the package.  All calls to `t_` that come from this package will use this registered translator.

Why would we want to do this?  If we were using [plumber](https://www.rplumber.io/) to build an API we might want to allow the requests to come in with a header indicating the language.  Our plumber api might look like:

```{r, results = "asis", echo = FALSE}
content <- readLines(file.path(path_hello, "inst", "plumber.R"))
lang_output("r", content)
```

The first endpoint inspects the endpoint's `req` object to get the requested language, but the second gets it automagically.  This can be understood by looking at the code used to run the API:

```{r, results = "asis", echo = FALSE}
content <- readLines(file.path(path_hello, "R", "api.R"))
lang_output("r", content[!grepl("^#", content)])
```

So at the beginning of each api request we are calling `traduire::translator_set_language`, which affects only this package as a ["preroute" hook](https://www.rplumber.io/docs/programmatic-usage.html#router-hooks) and resetting this in the "postserialize" hook.

The full package is available at `system.file("hello", package = "traduire")`.  If you run the API, it can be used like:

```
$ curl -H "Accept-Language: fr" http://localhost:8888

 -----
Salut le monde !
 ------
    \   ^__^
     \  (oo)\ ________
        (__)\         )\ /\
             ||------w|
             ||      ||
$ curl -H "Accept-Language: en" http://localhost:8888

 -----
Hello world!
 ------
    \   ^__^
     \  (oo)\ ________
        (__)\         )\ /\
             ||------w|
             ||      ||

$ curl -H "Accept-Language: ko" http://localhost:8888/hello/cat

 --------------
반갑다 세상아
 --------------
    \
      \
        \
            |\___/|
          ==) ^Y^ (==
            \  ^  /
             )=*=(
            /     \
            |     |
           /| | | |\
           \| | |_|/\
      jgs  //_// ___/
               \_)
```
