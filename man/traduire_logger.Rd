% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/logging.R
\name{traduire_logger}
\alias{traduire_logger}
\title{Create a logging function}
\usage{
traduire_logger(transform = NULL, format = NULL, emit = NULL)
}
\arguments{
\item{transform}{A transformation function - takes arguments
\code{level}, \code{key}, \code{data} and returns \code{data},
suitably transformed, but in any format.  This will be passed as
\code{data} to \code{format}.}

\item{format}{A formatting function - takes arguments
\code{level}, \code{key} and \code{data}, and returns an object
suitable for the \code{data} element of the \code{emit}
function.}

\item{emit}{An emmitting function, used for its side effect of
printing (or otherwise shipping) the log value.  You might use
this to write to a file, log to a database, or log to the screen
with different colours (perhaps using the \code{crayon} package,
for example).  Note that the default function will throw an
error on i18next errors, though this only occurs for
interpolation errors from the look of the i18next source.}
}
\description{
Create a function suitable for logging from traduire.  This
approach splits the logging process into three steps: (1)
transform, (2) format, (3) emit.  You can provide functions that
carry out any of these steps, falling back on reasonable defaults.
The default logger lightly processes the i18next output, formats
it as a string suitable for display to screen, and then uses
\code{message} to send it to the console.
}
\details{
The \code{transform} stage will recieve data like \code{level =
"warn", key = "i18next::translator: missingKey", [...]} where the
last value is an array of json values.  There is no reference as
to what the keys or data might be, save for reading the
\code{i18next} source code.  The default transformation attempts
to unmarshal the json data in a sensible way, and will return
either a named or an vector for the \code{data}.  We will try and
improve this function, and hopefully this default \code{transform}
stage will be generally useable.

The \code{format} function will recieve the same \code{level} and
\code{key} values as \code{transform}, but whatever
\code{transform} transforms the \code{data} into as its
\code{data} argument, You can use transform to use alternative
string interpolations that better suit your logging needs (e.g.,
adding a timestamp, or other contextual information about the
state of the application if you make that available through use of
an appropriate closure.

The \code{emit} function is the simplest and probably the most
sensible to provide a custom value for. You can log to however
many sources you want (e.g., both send to screen and to a
database).  The return value is ignored.

If you throw an error in any of these functions, it will not be
caught.
}
\examples{
# Create a closure that appends to a file
file_appender <- function(path) {
  function(level, key, data) {
    con <- file(path, "a")
    on.exit(close(con))
    writeLines(data, con)
  }
}

# Then create a logger from this
path <- tempfile()
logger <- traduire::traduire_logger(emit = file_appender(path))

# We can then pass that through to the constructor
resources <- system.file("examples/simple.json", package = "traduire")
obj <- traduire::i18n(resources, debug = TRUE, logger = logger)
obj$t("nonexistant")

# Our missed key is present in the file
readLines(path)
}
